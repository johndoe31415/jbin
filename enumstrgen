#!/usr/bin/python3
#	jbin - Joe's miscellaneous scripts, tools and configs
#	enumstrgen: Generate header/source files to print enum values of C code
#	Copyright (C) 2018-2024 Johannes Bauer
#
#	This file is part of jbin.
#
#	jbin is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; this program is ONLY licensed under
#	version 3 of the License, later versions are explicitly excluded.
#
#	jbin is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with jbin. If not, see <http://www.gnu.org/licenses/>.
#
#	Johannes Bauer <JohannesBauer@gmx.de>

import sys
import re
import os
from FriendlyArgumentParser import FriendlyArgumentParser

enum_re = re.compile("enum\s+(?P<enum_name>[_a-zA-Z][_a-zA-Z0-9]*)\s*{(?P<enum_content>[^}]+?)}", flags = re.MULTILINE)

class ParsedEnum():
	_ENUM_LINE = re.compile("\s*(?P<enum_name>[_a-zA-Z][_a-zA-Z0-9]*)(\s*=\s*(?P<enum_value>[^,]+))?\s*,\s*((//|/\*(!<)?)\s*(?P<enum_comment>.*?)\s*(\*/))?")

	def __init__(self, name, content, header_filename):
		self._name = name
		self._header_filename = header_filename
		self._items = { }
		self._parse(content)
		self._have_descriptions = any(comment is not None for (value, (name, comment)) in self)

	def _parse(self, content):
		last_enum_value = -1
		for line in content.split("\n"):
			rematch = self._ENUM_LINE.fullmatch(line)
			if rematch is not None:
				rematch = rematch.groupdict()
				if rematch["enum_value"] is not None:
					value = int(rematch["enum_value"], 0)
				else:
					value = last_enum_value + 1
				last_enum_value = value
				name = rematch["enum_name"]
				comment = rematch["enum_comment"]
				if value not in self._items:
					self._items[value] = (name, comment)

	@property
	def name(self):
		return self._name

	@property
	def maxvalue(self):
		return max(value for (value, (name, comment)) in self)

	@property
	def have_descriptions(self):
		return self._have_descriptions

	@property
	def header_filename(self):
		return self._header_filename

	@property
	def sparse(self):
		return (self.maxvalue - len(self._items)) > 10

	def __len__(self):
		return len(self._items)

	def __iter__(self):
		return iter(sorted(self._items.items()))

parser = FriendlyArgumentParser(description = "Create a string representation of enums.")
parser.add_argument("-o", "--output-filename", metavar = "prefix", default = "enum_str", help = "Output filename, defaults to %(default)s.")
parser.add_argument("-f", "--force", action = "store_true", help = "Do not ask for confirmation")
parser.add_argument("-v", "--verbose", action = "count", default = 0, help = "Increases verbosity. Can be specified multiple times to increase.")
parser.add_argument("headerfile", nargs = "+", help = "Header files to parse for enums.")
args = parser.parse_args(sys.argv[1:])


parsed_enums = [ ]
for header_filename in args.headerfile:
	with open(header_filename) as f:
		text = f.read()
	for rematch in enum_re.finditer(text):
		rematch = rematch.groupdict()
		parsed_enum = ParsedEnum(rematch["enum_name"], rematch["enum_content"], header_filename)
		if len(parsed_enum) > 0:
			parsed_enums.append(parsed_enum)
		else:
			if args.verbose >= 1:
				print(f"Warning: empty enum ignored: enum {rematch['enum_name']}")

c_filename = args.output_filename + ".c"
h_filename = args.output_filename + ".h"
if not args.force and os.path.exists(c_filename):
	raise FileExistsError(f"Refusing to overwrite: {c_filename}")
if not args.force and os.path.exists(h_filename):
	raise FileExistsError(f"Refusing to overwrite: {h_filename}")

with open(h_filename, "w") as f:
	print("// File automatically generated by enumstrgen. Do not modify.", file = f)
	print(f"#ifndef __{h_filename.upper().replace('.', '_')}__", file = f)
	print(f"#define __{h_filename.upper().replace('.', '_')}__", file = f)
	print(file = f)
	print("#include <stddef.h>", file = f)
	included = set()
	for parsed_enum in parsed_enums:
		if parsed_enum.header_filename not in included:
			print(f"#include \"{parsed_enum.header_filename}\"", file = f)
			included.add(parsed_enum.header_filename)
	print(file = f)
	for parsed_enum in parsed_enums:
		print(f"const char *enum_{parsed_enum.name}_get_symbol(enum {parsed_enum.name} value);", file = f)
		if parsed_enum.have_descriptions:
			print(f"const char *enum_{parsed_enum.name}_get_description(enum {parsed_enum.name} value);", file = f)
	print(file = f)
	print("#endif", file = f)

def escape(text):
	return text.replace("\"", "\\\"")

with open(c_filename, "w") as f:
	print("// File automatically generated by enumstrgen. Do not modify.", file = f)
	print(f"#include \"{h_filename}\"", file = f)
	print(file = f)
	for parsed_enum in parsed_enums:
		if parsed_enum.sparse:
			continue
		print(f"static const char *symbols_enum_{parsed_enum.name}[] = {{", file = f);
		for (value, (name, comment)) in parsed_enum:
			print(f"	[{name}] = \"{name}\",", file = f)
		print("};", file = f)
		print(file = f)
		if parsed_enum.have_descriptions:
			print(f"static const char *descriptions_enum_{parsed_enum.name}[] = {{", file = f);
			for (value, (name, comment)) in parsed_enum:
				if comment is not None:
					print(f"	[{name}] = \"{escape(comment)}\",", file = f)
			print("};", file = f)
			print(file = f)

	for parsed_enum in parsed_enums:
		if not parsed_enum.sparse:
			print(f"const char *enum_{parsed_enum.name}_get_symbol(enum {parsed_enum.name} value) {{", file = f)
			print(f"	if (value <= {parsed_enum.maxvalue}) {{", file = f)
			print(f"		return symbols_enum_{parsed_enum.name}[value];", file  = f)
			print("	} else {", file = f)
			print(f"		return NULL;", file  = f)
			print("	}", file = f)
			print("};", file = f)
			print(file = f)
			if parsed_enum.have_descriptions:
				print(f"const char *enum_{parsed_enum.name}_get_description(enum {parsed_enum.name} value) {{", file = f)
				print(f"	if (value <= {parsed_enum.maxvalue}) {{", file = f)
				print(f"		return descriptions_enum_{parsed_enum.name}[value];", file  = f)
				print("	} else {", file = f)
				print(f"		return NULL;", file  = f)
				print("	}", file = f)
				print("};", file = f)
				print(file = f)
		else:
			print(f"const char *enum_{parsed_enum.name}_get_symbol(enum {parsed_enum.name} value) {{", file = f)
			print("	switch (value) {", file = f)
			for (value, (name, comment)) in parsed_enum:
				print(f"		case {name}: return \"{name}\";", file = f)
			print("		default: return NULL;", file = f)
			print("	}", file = f)
			print("};", file = f)
			print(file = f)
			if parsed_enum.have_descriptions:
				print(f"const char *enum_{parsed_enum.name}_get_description(enum {parsed_enum.name} value) {{", file = f)
				print("	switch (value) {", file = f)
				for (value, (name, comment)) in parsed_enum:
					if comment is not None:
						print(f"		case {name}: return \"{escape(comment)}\";", file = f)
				print("		default: return NULL;", file = f)
				print("	}", file = f)
				print("};", file = f)
				print(file = f)
